{"version":3,"sources":["services/persons.js","components/DisplayPeople.js","components/Search.js","components/Form.js","components/Notification.js","App.js","serviceWorker.js","index.js"],"names":["baseUrl","axios","get","newPerson","post","id","delete","newObject","put","then","response","data","DisplayPeople","props","className","person","name","number","onClick","deletePerson","Search","value","searchTerm","onChange","Form","onSubmit","addPerson","newName","handleNameChange","newNumber","handleNumberChange","type","Notification","notification","message","App","useState","persons","setPersons","setSearch","setNewName","setNewNumber","setNotification","useEffect","personService","console","log","catch","error","notifyWith","setTimeout","e","target","preventDefault","length","names","map","existing","find","p","window","confirm","returnedPerson","concat","filter","includes","key","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.0f1fa017.chunk.js","sourcesContent":["import axios from 'axios'\r\n\r\n// const baseUrl = 'http://localhost:3001/api/persons'\r\n// const baseUrl = 'https://murmuring-eyrie-61812.herokuapp.com/api/persons'\r\nconst baseUrl = '/api/persons'\r\n\r\nconst getPersons = () => {\r\n  return axios.get(baseUrl)\r\n}\r\n\r\nconst addPerson = (newPerson) => {\r\n  return axios.post(baseUrl, newPerson)\r\n}\r\n\r\nconst deletePerson = (id) => {\r\n  return axios.delete(`${baseUrl}/${id}`)\r\n}\r\n\r\nconst updateNumber = (id, newObject) => {\r\n  const request = axios.put(`${baseUrl}/${id}`, newObject)\r\n  return request.then((response) => response.data)\r\n}\r\n\r\nexport default {\r\n  getPersons,\r\n  addPerson,\r\n  deletePerson,\r\n  updateNumber,\r\n}\r\n","import React from 'react'\r\n\r\n// import personService from '../services/persons'\r\n\r\nexport const DisplayPeople = props => {\r\n  // console.log(\"props\", props)\r\n\r\n  return (\r\n    <div>\r\n      <div className=\"person\">\r\n        <ul >{props.person.name}  {props.person.number}</ul>\r\n        <button className=\"deleteBtn\" onClick={() => props.deletePerson(props.person.id)}>Delete</button>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","import React from 'react'\r\n\r\nexport const Search = props => {\r\n  return (\r\n    <div>\r\n      Name Search: <input value={props.searchTerm} onChange={props.onChange}/>\r\n    </div>\r\n  )\r\n}\r\n","import React from 'react'\r\n\r\nexport const Form = props => {\r\n  return (\r\n    <div>\r\n      <form onSubmit={props.addPerson}>\r\n        <div>\r\n          name: <input value={props.newName} onChange={props.handleNameChange}/>\r\n        </div>\r\n        <div>\r\n          number: <input value={props.newNumber} onChange={props.handleNumberChange}/>\r\n        </div>\r\n        <div>\r\n          <button type=\"submit\">add</button>\r\n        </div>\r\n      </form>\r\n    </div>\r\n  )\r\n}\r\n","import React from 'react'\r\n\r\nexport const Notification = ({ notification }) => {\r\n\r\n  if (notification === null) {\r\n    return null\r\n  }\r\n\r\n  return (\r\n    <div className={notification.type}>\r\n      {notification.message}\r\n    </div>\r\n  )\r\n}\r\n","import React, { useState, useEffect } from 'react'\nimport './App.css'\n\nimport personService from './services/persons'\n\nimport { DisplayPeople } from './components/DisplayPeople'\nimport { Search } from './components/Search'\nimport { Form } from './components/Form'\nimport { Notification } from './components/Notification'\n\nconst App = () => {\n  const [persons, setPersons] = useState([])\n  const [searchTerm, setSearch] = useState('')\n  const [newName, setNewName] = useState('')\n  const [newNumber, setNewNumber] = useState('')\n  const [notification, setNotification] = useState(null)\n\n  useEffect(() => {\n    personService\n      .getPersons()\n      .then((response) => {\n        console.log('persons', response.data)\n        setPersons(response.data)\n      })\n      .catch((error) => console.log(error))\n  }, [])\n\n  const handleSearchChange = (e) => {\n    setSearch(e.target.value)\n  }\n\n  const handleNameChange = (e) => {\n    setNewName(e.target.value)\n  }\n\n  const handleNumberChange = (e) => {\n    setNewNumber(e.target.value)\n  }\n\n  const notifyWith = (message, type = 'success') => {\n    setNotification({ message, type })\n    setTimeout(() => {\n      setNotification(null)\n    }, 5000)\n  }\n\n  const addPerson = (e) => {\n    e.preventDefault()\n    const newPerson = {\n      name: newName,\n      number: newNumber,\n      id: persons.length + 1,\n    }\n    const names = persons.map((person) => person.name)\n    console.log(names)\n\n    const existing = persons.find((p) => p.name === newName)\n    console.log('newName', newName)\n    console.log('existing', existing)\n\n    // if (names.includes(newName)) {\n    if (existing) {\n      const ok = window.confirm(\n        `${existing.name} already in phonebook, replace the old number with new one?`\n      )\n      if (ok) {\n        personService\n          .updateNumber(existing.id, {\n            name: existing.name,\n            number: newNumber,\n          })\n          .then((returnedPerson) => {\n            setPersons(\n              persons.map((person) =>\n                person.id !== existing.id ? person : returnedPerson\n              )\n            )\n            notifyWith(`Changed number of ${existing.name}`)\n          })\n        setNewName('')\n        setNewNumber('')\n      }\n    } else {\n      console.log('persons', persons)\n      personService.addPerson(newPerson).then((response) => {\n        setPersons(persons.concat(newPerson))\n        notifyWith(`${newName} added to the list`)\n        setNewName('')\n        setNewNumber('')\n      })\n    }\n  }\n\n  const deletePerson = (id) => {\n    personService.deletePerson(id)\n    console.log('after delete', persons)\n    setPersons(persons.filter((person) => person.id !== id))\n  }\n\n  return (\n    <div>\n      <h2>Banana Phone</h2>\n      <div>\n        <Search searchTerm={searchTerm} onChange={handleSearchChange} />\n        {/* Name Search: <input value={searchTerm} onChange={handleSearchChange}/> */}\n      </div>\n      <h2>Add New Record</h2>\n      <Notification notification={notification} />\n      <Form\n        addPerson={addPerson}\n        handleNameChange={handleNameChange}\n        handleNumberChange={handleNumberChange}\n        newName={newName}\n        newNumber={newNumber}\n      />\n      <h2>Numbers</h2>\n      {persons\n        .filter((person) => person.name.includes(searchTerm))\n        .map((person) => (\n          <DisplayPeople\n            key={person.id}\n            person={person}\n            searchTerm={searchTerm}\n            deletePerson={() => deletePerson(person.id)}\n          />\n        ))}\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}